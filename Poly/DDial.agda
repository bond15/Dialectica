{-# OPTIONS --allow-unsolved-metas #-}
module DDial where 

-- TODO copy this file, but add the condition to Poly.. see what breaks
-- And refactor definitions to not use record projections
open import Agda.Primitive using (Level; lsuc)
-- open import Data.Unit using
open import Agda.Builtin.Sigma 
open import Cubical.Categories.Category.Base
open import Cubical.Core.Everything 
open import Cubical.Foundations.Prelude 
open import Function using (_‚àò_)
open import Data.Product
open import Data.Sum.Base using (_‚äé_; inj‚ÇÅ ; inj‚ÇÇ)

open import Lineale


module _ {‚Ñì}(L : Set ‚Ñì) {{pro : Proset L}} {{ mon : MonProset L }} {{lin : Lineale L }} where 
    record DDial : Set (lsuc ‚Ñì) where
        constructor _‚ñπ_c_
        field
            pos : Set
            dir : pos -> Set
            Œ± : (p : pos) ‚Üí dir p ‚Üí L

    record DDialMap (p q : DDial) : Set ‚Ñì where
        constructor _‚àß_st_
        open DDial p renaming (pos to pos‚ÇÅ; dir to dir‚ÇÅ)
        open DDial q renaming (pos to pos‚ÇÇ; dir to dir‚ÇÇ; Œ± to Œ≤)
        open Proset pro renaming (rel to _‚â§_)
        field


            f : pos‚ÇÅ ‚Üí pos‚ÇÇ
            F : (p : pos‚ÇÅ) ‚Üí dir‚ÇÇ (f p) ‚Üí dir‚ÇÅ p
            cond  : (p : pos‚ÇÅ)(d' : dir‚ÇÇ (f p)) ‚Üí Œ± p (F p d') ‚â§ Œ≤  (f p) d'
            

    _‚àòL_ : {A B C : DDial} ‚Üí (DDialMap B C) ‚Üí (DDialMap A B) ‚Üí (DDialMap A C)
    _‚àòL_ {A} {B} {C} record { f = g ; F = G ; cond = cond‚ÇÅ } record { f = f ; F = F ; cond = cond‚ÇÇ } = thing
        where 
            open DDial A renaming (pos to pos‚ÇÅ; dir to dir‚ÇÅ) 
            open DDial B renaming (pos to pos‚ÇÇ; dir to dir‚ÇÇ; Œ± to Œ≤)
            open DDial C renaming (pos to pos‚ÇÉ; dir to dir‚ÇÉ; Œ± to …£)

            open Proset pro renaming (rel to _‚â§_) 
            
            F' : (p : pos‚ÇÅ) ‚Üí dir‚ÇÉ (g (f p)) ‚Üí dir‚ÇÅ p
            F' p‚ÇÅ d‚ÇÉ = 
                        let p‚ÇÇ = f p‚ÇÅ
                            d‚ÇÇ = G p‚ÇÇ d‚ÇÉ
                            d‚ÇÅ = F p‚ÇÅ d‚ÇÇ
                        in  d‚ÇÅ
            cond' : (p : pos‚ÇÅ) (d' : dir‚ÇÉ (g (f p))) ‚Üí (Œ± p (F' p d')) ‚â§ (…£ (g (f p)) d')
            cond' p‚ÇÅ d‚ÇÉ = let p‚ÇÇ = f p‚ÇÅ
                              d‚ÇÇ = G p‚ÇÇ d‚ÇÉ
                              r1 = cond‚ÇÅ p‚ÇÇ d‚ÇÉ
                              r2 = cond‚ÇÇ p‚ÇÅ d‚ÇÇ 
                          in ptrans r2 r1

            thing : DDialMap A C
            thing = record { f = g ‚àò f ; F = F' ; cond = cond' }

    open Precategory

    idD : (x : DDial) ‚Üí DDialMap x x 
    idD (pos ‚ñπ dir c Œ±) = (Œª z ‚Üí z) ‚àß (Œª p z ‚Üí z) st (Œª p d' ‚Üí prefl)
        where 
            open Proset pro
    
    module eqaulityofmaps {A B : DDial}{m‚ÇÅ m‚ÇÇ : DDialMap A B} where 
        open DDial A renaming (pos to pos‚ÇÅ; dir to dir‚ÇÅ; Œ± to Œ±‚ÇÅ)
        open DDial B renaming (pos to pos‚ÇÇ; dir to dir‚ÇÇ; Œ± to Œ±‚ÇÇ)
        open DDial B
        open DDialMap m‚ÇÅ renaming (cond¬†to cond‚ÇÅ)
        open DDialMap m‚ÇÇ renaming (f to g; F to G; cond to cond‚ÇÇ)
        eq-maps : f ‚â° g ‚Üí PathP {!   !} F G ‚Üí PathP {!   !} cond‚ÇÅ cond‚ÇÇ ‚Üí {!   !}
        eq-maps = {!   !}
    
    DDialCat : Precategory (lsuc ‚Ñì) ‚Ñì
    DDialCat .ob = DDial
    DDialCat .Hom[_,_] = DDialMap
    DDialCat .id = idD 
    DDialCat ._‚ãÜ_ f g = g ‚àòL f
    DDialCat .‚ãÜIdL f = {!   !}
    DDialCat .‚ãÜIdR = {!   !}
    DDialCat .‚ãÜAssoc = {!   !}
            
    _‚äó_ : DDial ‚Üí DDial ‚Üí DDial 
    (pos‚ÇÅ ‚ñπ dir‚ÇÅ c Œ±‚ÇÅ) ‚äó (pos‚ÇÇ ‚ñπ dir‚ÇÇ c Œ±‚ÇÇ) = (pos‚ÇÅ √ó pos‚ÇÇ) ‚ñπ (Œª { (p‚ÇÅ , p‚ÇÇ) ‚Üí dir‚ÇÅ p‚ÇÅ √ó dir‚ÇÇ p‚ÇÇ}) c Œª{ (p‚ÇÅ , p‚ÇÇ) (d‚ÇÅ , d‚ÇÇ) ‚Üí Œ±‚ÇÅ p‚ÇÅ d‚ÇÅ ‚äô Œ±‚ÇÇ p‚ÇÇ d‚ÇÇ}
        where 
            open MonProset mon

    [_,_] : DDial ‚Üí DDial ‚Üí DDial
    [ pos‚ÇÅ ‚ñπ dir‚ÇÅ c Œ±‚ÇÅ , pos‚ÇÇ ‚ñπ dir‚ÇÇ c Œ±‚ÇÇ ] = 
        Œ£ (pos‚ÇÅ ‚Üí pos‚ÇÇ) (Œª f ‚Üí (p‚ÇÅ : pos‚ÇÅ)‚Üí dir‚ÇÇ (f p‚ÇÅ) ‚Üí dir‚ÇÅ p‚ÇÅ) ‚ñπ (Œª{ (f , F) ‚Üí Œ£ pos‚ÇÅ (Œª p‚ÇÅ ‚Üí dir‚ÇÇ (f p‚ÇÅ))}) c 
            Œª{ (f , F) (u , y) ‚Üí Œ±‚ÇÅ u (F u y) ‚ä∏ Œ±‚ÇÇ (f u) y}
        where 
            open Lineale.Lineale lin

{- 
[_,_] : {‚Ñì : Level} ‚Üí DialSet {‚Ñì} ‚Üí DialSet {‚Ñì} ‚Üí DialSet {‚Ñì}
[ ‚ü® pos , dir , Œ± ‚ü© , ‚ü® pos' , dir' , Œ≤ ‚ü© ] = ‚ü® (pos ‚Üí pos') √ó (pos √ó¬†dir' ‚Üí dir) , pos √ó dir' , m ‚ü© 
    where m : (pos ‚Üí pos') √ó ((pos √ó¬†dir' ‚Üí dir)) ‚Üí pos √ó dir' ‚Üí Two 
          m (uv , uyx) (u , y) = Œ± u (uyx (u , y)) ‚äó¬≤ Œ≤ (uv u) y
-}

    {-
    record { pos = pos ; dir = dir ; Œ± = Œ± } ‚äó record { pos = pos' ; dir = dir' ; Œ± = Œ≤ } = 
        record { pos = pos √ó pos' ; dir = Œª{(p , p') ‚Üí dir p √ó dir' p'} ; Œ± = Œª{ (p , p') (d , d') ‚Üí {!   !} }}   
-}
    
{- 


_‚àò‚Çö_ : {p q r : Poly} ‚Üí PolyMap q r ‚Üí  PolyMap q p ‚Üí PolyMap p r
_‚àò‚Çö_ {p}{q}{r}(onPos‚ÇÇ ‚áí‚Çö onDir‚ÇÇ)(onPos‚ÇÅ ‚áí‚Çö onDir‚ÇÅ) = goal 
    where 
        goal : PolyMap p r 
        goal = {!   !} ‚áí‚Çö {!   !}

    


‚¶Ö_‚¶Ü : Poly ‚Üí Set ‚Üí Set
‚¶Ö P ‚ñπ D ‚¶Ü X = Œ£[ p ‚àà P ] (D p ‚Üí X)

-- the 4 monoidal structures on Poly

_‚äé‚Çö_ : Poly ‚Üí Poly ‚Üí Poly
p ‚äé‚Çö q = record { pos = pos p ‚äé pos q ; dir = Œª { (inj‚ÇÅ x) ‚Üí (dir p) x
                                                ; (inj‚ÇÇ y) ‚Üí (dir q) y } }

-- Ay·¥Æ √ó Cy·¥∞ = ACy·¥Æ‚Å∫·¥∞
_√ó‚Çö_ : Poly ‚Üí Poly ‚Üí Poly
p √ó‚Çö q = record { pos = pos p √ó pos q ; dir = Œª {(i , j) ‚Üí (dir p) i ‚äé (dir q) j} }

--tensor \ox
-- Ay·¥Æ √ó Cy·¥∞ = ACy·¥Æ·¥∞
_‚äó‚Çö_ : Poly ‚Üí Poly ‚Üí Poly
p ‚äó‚Çö q = record { pos = pos p √ó pos q ; dir = Œª {(i , j) ‚Üí (dir p) i √ó (dir q) j} }
-- show these are all monoidal structures on poly

-- composition of polynomials
-- notation suggests that p ‚óÉ q, means that q is substituted into p
-- show that this is an example of composition of datatypes!

_‚óÉ_ : Poly ‚Üí Poly ‚Üí Poly
(p‚ë¥ ‚ñπ p[_] ) ‚óÉ (q‚ë¥ ‚ñπ q[_]) = (Œ£[ i ‚àà p‚ë¥ ] (p[ i ] ‚Üí q‚ë¥)) ‚ñπ Œª{ ( i , jÃÇ) ‚Üí Œ£[ d ‚àà p[ i ] ]  q[ (jÃÇ d) ]}


record Poly‚Çì (p q : Poly) : Set where
    field
        pos‚Çì : pos p √ó pos q
        dir‚Çì : (pq : pos p √ó pos q) ‚Üí (dir p) (fst pq) ‚äé (dir q) (snd pq) 


record Poly[_,_](p q : Poly) : Set where
    constructor _‚áí‚Çö_
    field
        onPos : pos p ‚Üí pos q
        onDir : (i : pos p) ‚Üí dir q (onPos i) ‚Üí dir p i
open Poly[_,_]

-- RENAME 
_‚áí‚àò‚Çö_ : {p q r : Poly} ‚Üí Poly[ p , q ] ‚Üí Poly[ q , r ] ‚Üí Poly[ p , r ]
pq ‚áí‚àò‚Çö qr = record { onPos = (onPos pq) ÿõ (onPos qr) -- forward composition on positions
                  ; onDir = Œª i ‚Üí ((onDir pq) i) ‚àò ((onDir qr) ((onPos pq) i)) } -- backward composition on directions

-- Chart
-- forward on positions and forward on arrows
--https://www.youtube.com/watch?v=FU9B-H6Tb4w&list=PLhgq-BqyZ7i6IjU82EDzCqgERKjjIPlmh&index=9
-- found DJM's book! http://davidjaz.com/Papers/DynamicalBook.pdf
record Chart (p q : Poly) : Set where
    field
        onPos : pos p ‚Üí pos q
        onDir : (i : pos p) ‚Üí dir p i ‚Üí dir q (onPos i)

-- write out the commuting square between the 4 polys

Poly[] : Poly ‚Üí Poly ‚Üí Set
Poly[] p q = ‚àÄ (i : pos p) ‚Üí Œ£ (pos q) (Œª (j : pos q) ‚Üí ‚àÄ (d : dir q j) ‚Üí Œ£ (dir p i) Œª c ‚Üí Unit )


lemma-poly[]-iso : {p q : Poly} ‚Üí Poly[] p q ‚âà Poly[ p , q ]
lemma-poly[]-iso {p} {q} = record { to = Œª p[] ‚Üí record { onPos = Œª ppos ‚Üí fst( p[] ppos) ; onDir = Œª ppos x ‚Üí fst(snd(p[] ppos) x) } 
                        ; from = Œª poly[p,q] ppos ‚Üí (onPos poly[p,q]) ppos , Œª d ‚Üí (onDir poly[p,q]) ppos d , unit 
                        ; from‚àòto = Œª poly[]pq ‚Üí  {!   !} --Extensionality Œª x ‚Üí {! ? !}
                        ; to‚àòfrom = Œª poly[p,q] ‚Üí {!   !} }

elem : Poly ‚Üí Set
elem p = Œ£ (pos p) (dir p)


lift : {X Y : Set} ‚Üí (p : Poly) ‚Üí (X ‚Üí Y) ‚Üí (‚¶Ö p ‚¶Ü X ‚Üí ‚¶Ö p ‚¶Ü Y)
lift p f = Œª{ (fst‚ÇÅ , snd‚ÇÅ) ‚Üí fst‚ÇÅ , snd‚ÇÅ ÿõ f}

yÀ¢ : (S : Set) ‚Üí Poly
yÀ¢ S = Unit ‚ñπ Œª _ ‚Üí S

ùìé : Poly
ùìé = Unit ‚ñπ (Œª _ ‚Üí Unit)

yoneda : {S : Set} ‚Üí {q : Poly} ‚Üí Poly[ yÀ¢ S , q ] ‚âà ‚¶Ö q ‚¶Ü S
yoneda =  record { to = Œª{ record { onPos = onPos ; onDir = onDir } ‚Üí onPos unit , Œª x ‚Üí onDir unit x } 
                    ; from = Œª { (fst‚ÇÅ , snd‚ÇÅ) ‚Üí record { onPos = Œª _ ‚Üí fst‚ÇÅ ; onDir = Œª i ‚Üí snd‚ÇÅ } } 
                    ; from‚àòto = Œª{ record { onPos = onPos ; onDir = onDir } ‚Üí {! refl  !} } 
                    ; to‚àòfrom = Œª { (fst‚ÇÅ , snd‚ÇÅ) ‚Üí {!   !} }}


-- Day 5 (Closures)
-- Poly(p ‚äó q , r) ‚âà Poly (p , [q , r])
-- Poly(p √ó q , r) ‚âà Poly (p , q ≥)
-- where [q , r] and q ≥ are not defined here yet


-- Set^Vars ‚Üí Set
-- or Set^I ‚Üí Set
record Poly‚Çò (Vars : Set) : Set where
    constructor _‚ñπ‚Çò_
    field
        Pos : Set
        Dir : Pos ‚Üí ‚àÄ (var : Vars) ‚Üí Set

‚¶Ö_‚¶Ü‚ãÜ_ : {Vars : Set} ‚Üí Poly‚Çò Vars ‚Üí (Vars ‚Üí Set) ‚Üí Set 
(‚¶Ö_‚¶Ü‚ãÜ_) {Vars} (Pos ‚ñπ‚Çò Dir) f = Œ£[ p ‚àà Pos ] (‚àÄ (var : Vars) ‚Üí (Dir p var ‚Üí f var ))

-- https://www.youtube.com/watch?v=B8STLcbEGrE&list=PLhgq-BqyZ7i7R-fGcAmNyWmJBQg1wzex-&index=1
-- Richard Garner's talk
-- the even more general case is 
-- Set^I ‚Üí Set^J 
-- "A J indexed family of polynomial functors Set^I ‚Üí Set"
-- claim: this is better for composition ?

-- Alternatively functors Set/I ‚Üí Set/J ??
-- slice category?

-- another representation ( I've seen this before in some papers..)
-- Set/I ‚Üí Set/E ‚Üí Set/B ‚Üí Set/J

-- Also Girard's Normal Functors?


module ExampleMultivariate where
    open import Data.Bool
    open import Data.Nat

    -- set of variables
    data V : Set where
        X Y Z : V

    -- 3 variables X Y Z
    -- P(x,y,z) = (x^2)(z^3) + xz + 1
    mp : Poly‚Çò V
    mp = record { 
        Pos = Pos‚ÇÉ ; 
        Dir = Œª { P‚ÇÅ X ‚Üí Dir‚ÇÇ -- x^2
                ; P‚ÇÅ Y ‚Üí Dir‚ÇÄ
                ; P‚ÇÅ Z ‚Üí Dir‚ÇÉ -- z^3

                ; P‚ÇÇ X ‚Üí Dir‚ÇÅ -- x
                ; P‚ÇÇ Y ‚Üí Dir‚ÇÄ
                ; P‚ÇÇ Z ‚Üí Dir‚ÇÅ -- z

                ; P‚ÇÉ X ‚Üí Dir‚ÇÄ
                ; P‚ÇÉ Y ‚Üí Dir‚ÇÄ
                ; P‚ÇÉ Z ‚Üí Dir‚ÇÄ }}

    assignVars : V ‚Üí Set
    assignVars X = Bool
    assignVars Y = Unit
    assignVars Z = ‚Ñï

    _ : ‚¶Ö mp ‚¶Ü‚ãÜ assignVars 
    _ = P‚ÇÅ , Œª{X D‚ÇÅ ‚Üí true
             ; X D‚ÇÇ ‚Üí false

             ; Z D‚ÇÅ ‚Üí 1
             ; Z D‚ÇÇ ‚Üí 2
             ; Z D‚ÇÉ ‚Üí 3}

-- PolyBoxes
module composition where
    p : Poly  
    p = Pos‚ÇÇ ‚ñπ (Œª{P‚ÇÅ ‚Üí Dir‚ÇÇ
                ; P‚ÇÇ ‚Üí Dir‚ÇÅ})

    p' : Poly
    p' = Pos‚ÇÇ ‚ñπ Œª{P‚ÇÅ ‚Üí Dir‚ÇÉ
                ; P‚ÇÇ ‚Üí Dir‚ÇÅ}

    q : Poly
    q = Pos‚ÇÇ ‚ñπ (Œª{P‚ÇÅ ‚Üí Dir‚ÇÇ
                ; P‚ÇÇ ‚Üí Dir‚ÇÅ})

    q' : Poly
    q' = Pos‚ÇÇ ‚ñπ (Œª{P‚ÇÅ ‚Üí Dir‚ÇÅ
                 ; P‚ÇÇ ‚Üí Dir‚ÇÄ})


    p‚Üíp' : Poly[ p , p' ]
    p‚Üíp' = (Œª{P‚ÇÅ ‚Üí P‚ÇÅ
            ; P‚ÇÇ ‚Üí P‚ÇÇ}) ‚áí‚Çö Œª{P‚ÇÅ D‚ÇÅ ‚Üí D‚ÇÇ
                           ; P‚ÇÅ D‚ÇÇ ‚Üí D‚ÇÇ
                           ; P‚ÇÅ D‚ÇÉ ‚Üí D‚ÇÅ
                           ; P‚ÇÇ D‚ÇÅ ‚Üí D‚ÇÅ}

    q‚Üíq' : Poly[ q , q' ]
    q‚Üíq' = (Œª{P‚ÇÅ ‚Üí P‚ÇÅ
            ; P‚ÇÇ ‚Üí P‚ÇÇ}) ‚áí‚Çö Œª{P‚ÇÅ D‚ÇÅ ‚Üí D‚ÇÇ}

    _ : Poly[ p ‚óÉ q , p' ‚óÉ q' ]
    _ = {!   !}

    -- Sy^S is a contractible groupoid ??
    -- Day 6
    _‚óÉ‚Üí_ : {p p' q q' : Poly} ‚Üí (f : Poly[ p , p' ]) ‚Üí (g : Poly[ q , q' ]) ‚Üí Poly[ p ‚óÉ q , p' ‚óÉ q' ]
    (onPos‚ÇÅ ‚áí‚Çö onDir‚ÇÅ) ‚óÉ‚Üí (onPos‚ÇÇ ‚áí‚Çö onDir‚ÇÇ) = 
            (Œª{ (posp , pdirtoq) ‚Üí onPos‚ÇÅ posp , Œª{x ‚Üí onPos‚ÇÇ (pdirtoq (onDir‚ÇÅ posp x))}}) 
            ‚áí‚Çö Œª{(posp , snd‚ÇÅ) (fst‚ÇÅ , snd‚ÇÇ) ‚Üí (onDir‚ÇÅ posp fst‚ÇÅ) , (onDir‚ÇÇ (snd‚ÇÅ (onDir‚ÇÅ posp fst‚ÇÅ)) snd‚ÇÇ)}

    _ : {p q : Poly} ‚Üí Poly[ p ‚äó‚Çö q , p ‚óÉ q ]
    _ = (Œª{ (posp , posq) ‚Üí posp , Œª _ ‚Üí posq}) ‚áí‚Çö Œª{ _ (fst‚ÇÇ , snd‚ÇÇ) ‚Üí fst‚ÇÇ , snd‚ÇÇ}

    -- (p +‚Çö q) ‚óÉ r ‚âà (p ‚óÉ r) +‚Çö (q ‚óÉ r)
    -- (p √ó‚Çö q) ‚óÉ r ‚âà (p ‚óÉ r) √ó‚Çö (q ‚óÉ r)

-} 